import math

class Vector():
    def __init__(self, x,z):
        self.x = x
        self.z = z

    def rotate(self, theta):
        theta = math.radians(theta)
        cos = math.cos(theta)
        sin = math.sin(theta)

        nx = cos * self.x - sin * self.z
        nz = sin * self.x + cos * self.z

        return Vector(nx, nz)

    def add(self, v):
        return Vector(self.x+v.x,self.z+v.z)

    def sub(self, v):
        return Vector(self.x-v.x,self.z-v.z)
    
    def scale(self, scalar):
        return Vector(self.x * scalar, self.z * scalar)

    def __str__(self):
        return f"({self.x},{self.z})"

wall1length = 3.7 # in metres
wall2length = 5.5 # in metres
height=2.4 # in metres


wall1wus = (wall1length * 100) / 3
wall2wus = (wall2length * 100) / 3
hwus=(height*100)/3
angle=15

origin = Vector(0,0)
a=Vector(-1,-5.25)
ae=Vector(-12,-12).rotate(angle)

w1=Vector(wall1wus,0).rotate(angle)
w2=Vector(0,wall2wus).rotate(angle)
w3=Vector(-wall1wus,0).rotate(angle)
w4=Vector(0,-wall2wus).rotate(angle)

p1=a.add(ae)
p2=p1.add(w1)
p3=p2.add(w2)
p4=p3.add(w3)
p5=p4.add(w4)

iv = Vector(1,0).rotate(angle)
kv = Vector(0,1).rotate(angle)

# the wall will start 60cm below the table level = 20 wu
# table level = -0.8
# so y = -20.8
y_floor = -20.8

print("<!--    Generated by python file-->")
print("<!--         Walls-->")
for p,n,r in zip([p1,p2,p3,p4], [kv, iv.scale(-1), kv.scale(-1), iv],[-75,-75,15,15]):
    print(f'<plane x="{round(p.x,5)}" y="{y_floor}" z="{round(p.z,5)}" nx="{round(n.x*10,5)}" ny="0" nz="{round(n.z*10,5)}" kS="0.1" colour="#ae2eae" reflectivity="0" texture-map="stone_wall.jpg" texture-scale="183.5" texture-rotation="{r}"/>')

print("<!--         Floor-->")
# print the floor and ceiling
print(f'<plane x="{round(p1.x,5)}" y="{y_floor}" z="{round(p1.z,5)}" nx="0" ny="1" nz="0" kS="0.8" colour="#ae2eae" reflectivity="0.25" texture-map="floor_wood.jpg" texture-rotation="15" texture-scale="50"/>')

# the height of the room will be 2.4 metres above the ground, 240cm = 80wu

print("<!--         Ceiling-->")
print(f'<plane x="{round(p1.x,5)}" y="{y_floor+hwus}" z="{round(p1.z,5)}" nx="0" ny="-1" nz="0" kS="0.8" colour="#ae2eae" reflectivity="0" texture-map="plaster.jpg" texture-rotation="15" texture-scale="50"/>')
print("<!--    End generated by python file-->")


# 
def Proportions_to_object(name, xprop,yprop,zprop):
    # p1 is the starting point
    
    y=yprop*hwus
    xz = Vector(xprop*wall1wus,zprop*wall2wus)
    xzRot = xz.rotate(angle)

    newLoc=p1.add(xzRot)
    newx=newLoc.x
    newy=y_floor+y
    newz=newLoc.z

    print(f'<{name} x="{round(newx,5)}" y="{round(newy,5)}" z="{round(newz,5)}"/>')

print("\n\n")

# light in the room
Proportions_to_object("point-light", 0.5,0.99,0.5)
print("\n\n")
import random
import numpy as np

colourList=["#ff0038","#1dacd6", "#e3e3e3","#c7c7c7","#ff5252"]

def generate_random_tree_decorator(x,y,z):
    if random.randint(0,1) == 1:
        # generate light
        light=f'<point-light x="{round(x,5)}" y="{round(y,5)}" z="{round(z,5)}" colour="#f7e160" intensity="40"/>'
        return light
    else:
        # generate bauble
        # sample radius from normal distribution
        radius = min(max(0.6,np.random.normal(loc=1.4,scale=0.3)),2.8)
        colour = colourList[random.randint(0,len(colourList)-1)]
        reflectivity = random.choice(["0.04","0.3","0.8"])
        bumpy=np.random.choice(a=[True,False],p=[1/3,2/3])
        return f'<sphere x="{round(x,5)}" y="{round(y,5)}" z="{round(z,5)}" radius="{round(radius,5)}" colour="{colour}" reflectivity="{reflectivity}" {'bump-map="bumpy_bauble.jpg"' if bumpy else ""} />'


class Vector3():
    def __init__(self,x,y,z):
        self.x=x
        self.y=y
        self.z=z
    
    def sub(self, v):
        return Vector3(self.x-v.x,self.y-v.y,self.z-v.z)

    def mag(self):
        return math.sqrt(self.x**2 + self.y**2 + self.z**2)

def generate_tree_tags(angle):
    # height = 6.5 ft = 200cm = 67wus, width of 66cm
    height=67
    radius=22
    gap_x=10
    gap_y=5
    # 20cm clearance = 7wu
    clearance=7

    treestart = p3.add(Vector(-(radius+gap_x),-(radius+gap_y)).rotate(angle))
    
    startHeight = y_floor + clearance + height
   
    # bottom radius
    rad_to_deg = 360 / (2 * math.pi)
    treeangle = math.atan(radius/height) * rad_to_deg
    length = math.sqrt(height**2+radius**2)
    print("<!--    Generated by python file-->")
    print("<!--    Tree-->")
    print(f'<cone x="{round(treestart.x,5)}" y="{round(startHeight,5)}" z="{round(treestart.z,5)}" ax="0" ay="-1" az="0" angle="{round(treeangle,5)}" length="{round(length,5)}" texture-map="tree.jpg" kS="0" reflectivity="0"/>')
    print(f'<plane x="{round(treestart.x,5)}" y="{round(y_floor + clearance,5)}" z="{round(treestart.z,5)}" bx="{round(treestart.x,5)}" by="{round(y_floor + clearance,5)}" bz="{round(treestart.z,5)}" nx="0" ny="-1" nz="0" texture-map="tree.jpg" kS="0" reflectivity="0" texture-scale="10" bounding-radius="{radius}"/>')
    print(f'<cylinder x="{round(treestart.x,5)}" y="{round(y_floor + clearance,5)}" z="{round(treestart.z,5)}" ax="0" ay="-1" az="0" texture-map="bark.jpg" length="{clearance+0.1}" radius="{radius/6} reflectivity="0" kS="0"/>')


    # generate 50 random baubles and lights on this side of the tree, take +ve x to be theta = 0
    # sample from a triangular distribution to account for increasing surface area
    delta=0.7
    # triangular(min, peak, max)
    N=60
    distance_distribution = np.random.triangular(0+delta, length-delta, length-delta,N)
    randomTheta = np.random.uniform(0,math.pi,N)
    print("<!--       Baubles and lights-->")


    objectVecs=[]
    while len(objectVecs) < N:
        r = np.random.triangular(0+delta, length-delta, length-delta)
        theta = np.random.uniform(0,math.pi)

        # spherical coordiantes with r, tree angle and random angle

        # a value to make them outside of the tree
        epsilon=0.6

        deg_to_rad = (2*math.pi)/360

        # coords relative to treestart
        x = (r+epsilon) * math.sin(treeangle*deg_to_rad) * math.cos(theta)
        y = - r * math.cos(treeangle*deg_to_rad)
        z = - (r+epsilon) * math.sin(treeangle*deg_to_rad) * math.sin(theta)

        

        # get coords in the real world
        bx = treestart.x + x
        by = startHeight + y
        bz = treestart.z + z

        vec = Vector3(bx,by,bz)
        add = True
        for coord in objectVecs:
            if coord.sub(vec).mag() < 2.8 * 2:
                # could be an intersection
                add = False
        if add:
            obj = generate_random_tree_decorator(bx,by,bz)
            objectVecs.append(vec)
            print(obj)

    
    print("<!--    End generated by python file-->")

generate_tree_tags(angle)

print("\n\n")
Proportions_to_object("point-light", 0.995,0.1,0.5)
print("\n\n")

Proportions_to_object("window", 0.333,0.7,1)
xz=Vector(-20,20)
y=8
xzr= xz.rotate(angle)
# sun
print(f'<point-light x="{-17.26487+xzr.x}" y="{35.2+y}" z="{167.76916+xzr.z}" colour="#ffffff" intensity="10000"/>')

# create the sky plane
Proportions_to_object("sky", 1,0,10)
